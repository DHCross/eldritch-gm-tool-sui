<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Advanced Eldritch RPG Encounter Generator</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        /* Styling with greens and dark hues */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a2327;
            color: #e0e0e0;
        }
        h1 {
            text-align: center;
            color: #4CAF50;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        .slider-container {
            margin-bottom: 20px;
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .slider {
            width: 100%;
            -webkit-appearance: none;
            height: 15px;
            border-radius: 5px;
            background: #d3d3d3;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        .slider:hover {
            opacity: 1;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        .slider::-moz-range-thumb {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
#encounterOutput {
    white-space: pre-wrap;
    font-family: 'Arial', sans-serif; /* Changed to Arial for better readability */
    border: 1px solid #000;
    padding: 15px;
    margin-top: 20px;
    background-color: #fff; /* Set background to white */
    color: #000; /* Set text color to black */
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.3); /* Adjust for subtle shadow if needed */
    line-height: 1.5; /* Adds a bit of space between lines for better readability */
}

        .checkbox-container {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 20px;
            background-color: #2c3e50;
            padding: 15px;
            border-radius: 8px;
        }
        .checkbox-container label {
            margin-right: 15px;
            display: flex;
            align-items: center;
            cursor: pointer;
        }
        .checkbox-container input[type="checkbox"] {
            margin-right: 5px;
        }
        button {
            margin: 10px 0;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        label {
            display: block;
            margin-bottom: 5px;
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>Eldritch RPG Encounter Generator</h1>

    <div class="slider-container">
        <label for="partySize">Party Size: <span id="partySizeValue">4</span></label>
        <input type="range" id="partySize" min="1" max="4" value="4" class="slider">
    </div>

    <div class="slider-container">
        <label for="defenseLevel">Party Defense Level: <span id="defenseLevelValue">Practitioner</span></label>
        <input type="range" id="defenseLevel" min="1" max="5" value="1" class="slider">
    </div>

    <div class="slider-container">
        <label for="difficulty">Desired Difficulty: <span id="difficultyValue">Moderate</span></label>
        <input type="range" id="difficulty" min="1" max="6" value="2" class="slider">
    </div>

    <div class="slider-container">
        <label for="nonMediumPercentage">Non-Medium Size Percentage: <span id="nonMediumPercentageValue">10</span>%</label>
        <input type="range" id="nonMediumPercentage" min="0" max="100" value="10" class="slider">
    </div>

    <div class="slider-container">
        <label for="nonMundanePercentage">Non-Mundane Nature Percentage: <span id="nonMundanePercentageValue">20</span>%</label>
        <input type="range" id="nonMundanePercentage" min="0" max="100" value="20" class="slider">
    </div>

    <div class="slider-container">
        <label for="specialTypePercentage">Fast/Tough Creature Percentage: <span id="specialTypePercentageValue">30</span>%</label>
        <input type="range" id="specialTypePercentage" min="0" max="100" value="30" class="slider">
    </div>

    <div class="checkbox-container">
        <label><input type="checkbox" name="creatureTypes" value="Minor" checked> Minor</label>
        <label><input type="checkbox" name="creatureTypes" value="Standard" checked> Standard</label>
        <label><input type="checkbox" name="creatureTypes" value="Exceptional" checked> Exceptional</label>
        <label><input type="checkbox" name="creatureTypes" value="Legendary"> Legendary</label>
    </div>
    <div class="checkbox-container">
        <label style="width:100%;">Creature Tropes (pick one or more):</label>
        <label><input type="checkbox" name="creatureTropes" value="Human" checked> Human</label>
        <label><input type="checkbox" name="creatureTropes" value="Goblinoid" checked> Goblinoid</label>
        <label><input type="checkbox" name="creatureTropes" value="Beast" checked> Beast</label>
        <label><input type="checkbox" name="creatureTropes" value="Undead"> Undead</label>
        <label><input type="checkbox" name="creatureTropes" value="Construct"> Construct</label>
        <label><input type="checkbox" name="creatureTropes" value="Elemental"> Elemental</label>
        <label><input type="checkbox" name="creatureTropes" value="Aberration"> Aberration</label>
        <label><input type="checkbox" name="creatureTropes" value="Fey"> Fey</label>
        <label><input type="checkbox" name="creatureTropes" value="Dragon"> Dragon</label>
        <label><input type="checkbox" name="creatureTropes" value="Ooze"> Ooze</label>
        <label><input type="checkbox" name="creatureTropes" value="Demon"> Demon/Infernal</label>
    </div>

    <button onclick="generateEncounter()">Generate Encounter</button>

    <div id="encounterOutput"></div>

    <script>
        // Define difficulty and defense levels
        const difficultyLevels = ['Easy', 'Moderate', 'Difficult', 'Demanding', 'Formidable', 'Deadly'];
        const defenseLevels = ['Practitioner', 'Competent', 'Proficient', 'Advanced', 'Elite'];

        // Define encounter difficulty thresholds based on party size and defense level
        const encounterDifficultyTable = {
            1: {
                Practitioner: [7,10,12,14,16,18],
                Competent: [14,20,24,28,32,36],
                Proficient: [21,29,36,42,48,55],
                Advanced: [28,39,48,56,64,73],
                Elite: [35,49,60,70,80,110]
            },
            2: {
                Practitioner: [14,20,24,28,32,36],
                Competent: [28,39,48,56,64,73],
                Proficient: [42,59,72,84,96,108],
                Advanced: [56,77,96,112,128,144],
                Elite: [70,95,120,140,160,190]
            },
            3: {
                Practitioner: [21,30,36,42,48,54],
                Competent: [42,59,72,84,96,108],
                Proficient: [63,84,108,126,144,162],
                Advanced: [84,111,144,168,192,216],
                Elite: [105,140,180,210,240,270]
            },
            4: {
                Practitioner: [28,42,50,56,64,72],
                Competent: [56,77,96,112,128,144],
                Proficient: [84,111,144,168,192,216],
                Advanced: [112,147,180,224,256,288],
                Elite: [140,185,228,280,320,360]
            }
        };

        // Define Threat Dice by category
        const threatDiceByCategory = {
            Minor: ['1d4','1d6','1d8','1d10','1d12'],
            Standard: ['2d4','2d6','2d8','2d10','2d12'],
            Exceptional: ['3d4','3d6','3d8','3d10','3d12'],
            Legendary: ['3d12','3d14','3d16','3d18','3d20']
        };

        // Define HP multipliers based on size and nature
        const hpMultipliers = {
            'Minuscule': {'Mundane': 0.5, 'Magical': 1, 'Preternatural': 1.5, 'Supernatural': 2},
            'Tiny': {'Mundane': 0.5, 'Magical': 1, 'Preternatural': 1.5, 'Supernatural': 2},
            'Small': {'Mundane': 1, 'Magical': 1.5, 'Preternatural': 2, 'Supernatural': 2.5},
            'Medium': {'Mundane': 1, 'Magical': 1.5, 'Preternatural': 2, 'Supernatural': 2.5},
            'Large': {'Mundane': 1.5, 'Magical': 2, 'Preternatural': 2.5, 'Supernatural': 3},
            'Huge': {'Mundane': 2, 'Magical': 2.5, 'Preternatural': 3, 'Supernatural': 3.5},
            'Gargantuan': {'Mundane': 2.5, 'Magical': 3, 'Preternatural': 3.5, 'Supernatural': 4}
        };

        // Weighted random helper (expects an object of {key: weight})
        function weightedRandom(weights) {
            const entries = Object.entries(weights);
            const total = entries.reduce((sum, [, w]) => sum + w, 0);
            let r = Math.random() * total;
            for (const [key, w] of entries) {
                if ((r -= w) <= 0) return key;
            }
            // Fallback
            return entries[entries.length - 1][0];
        }

        // Trope configuration: size and nature tendencies
        const tropeConfig = {
            Human: {
                sizeWeights: { Small: 1, Medium: 8, Large: 1 },
                natureWeights: { Mundane: 8, Magical: 1, Preternatural: 0.5, Supernatural: 0.25 }
            },
            Goblinoid: {
                sizeWeights: { Small: 2, Medium: 7, Large: 1 },
                natureWeights: { Mundane: 6, Magical: 1, Preternatural: 0.5, Supernatural: 0.25 }
            },
            Beast: {
                sizeWeights: { Tiny: 1, Small: 3, Medium: 5, Large: 3, Huge: 1 },
                natureWeights: { Mundane: 9, Magical: 0.5, Preternatural: 0.5, Supernatural: 0.25 }
            },
            Undead: {
                sizeWeights: { Small: 1, Medium: 6, Large: 2, Huge: 1 },
                natureWeights: { Supernatural: 10 } // forced to Supernatural by weight
            },
            Construct: {
                sizeWeights: { Small: 1, Medium: 5, Large: 3, Huge: 1 },
                natureWeights: { Magical: 10 }
            },
            Elemental: {
                sizeWeights: { Small: 1, Medium: 4, Large: 3, Huge: 2 },
                natureWeights: { Preternatural: 8, Supernatural: 2 }
            },
            Aberration: {
                sizeWeights: { Small: 1, Medium: 4, Large: 3, Huge: 2 },
                natureWeights: { Preternatural: 6, Supernatural: 3, Magical: 1 }
            },
            Fey: {
                sizeWeights: { Tiny: 1, Small: 2, Medium: 6, Large: 1 },
                natureWeights: { Magical: 7, Preternatural: 2, Supernatural: 1 }
            },
            Dragon: {
                sizeWeights: { Medium: 2, Large: 5, Huge: 3, Gargantuan: 1 },
                natureWeights: { Preternatural: 6, Supernatural: 3, Magical: 1 }
            },
            Ooze: {
                sizeWeights: { Small: 2, Medium: 5, Large: 3 },
                natureWeights: { Preternatural: 7, Supernatural: 1, Mundane: 1, Magical: 1 }
            },
            Demon: {
                sizeWeights: { Medium: 4, Large: 4, Huge: 2 },
                natureWeights: { Supernatural: 9, Preternatural: 1 }
            }
        };

        function clampWeightsForNonMedium(sizeWeights, nonMediumPercentage) {
            // If user lowers nonMediumPercentage, allow Medium; if raises, reduce Medium presence
            const weights = { ...sizeWeights };
            if (weights.Medium !== undefined) {
                const pct = Math.max(0, Math.min(100, nonMediumPercentage));
                // Scale Medium weight inversely to pct (0% => 100% weight, 100% => 0 weight)
                const scale = (100 - pct) / 100;
                weights.Medium = weights.Medium * scale;
                // If Medium drops to ~0, ensure other sizes remain
                const sumOthers = Object.entries(weights).filter(([k]) => k !== 'Medium').reduce((s, [, w]) => s + w, 0);
                if (sumOthers === 0) weights.Medium = 1; // fallback
            }
            return weights;
        }

        function clampWeightsForNonMundane(natureWeights, nonMundanePercentage) {
            const weights = { ...natureWeights };
            if (weights.Mundane !== undefined) {
                const pct = Math.max(0, Math.min(100, nonMundanePercentage));
                const scale = (100 - pct) / 100;
                weights.Mundane = weights.Mundane * scale;
                const sumOthers = Object.entries(weights).filter(([k]) => k !== 'Mundane').reduce((s, [, w]) => s + w, 0);
                if (sumOthers === 0) weights.Mundane = 1; // fallback
            }
            return weights;
        }

        function getRandomTrope(selectedTropeValues) {
            return selectedTropeValues[Math.floor(Math.random() * selectedTropeValues.length)];
        }

        // Update slider values on input
        function updateSliderValues() {
            document.getElementById('partySizeValue').textContent = document.getElementById('partySize').value;
            document.getElementById('defenseLevelValue').textContent = defenseLevels[document.getElementById('defenseLevel').value - 1];
            document.getElementById('difficultyValue').textContent = difficultyLevels[document.getElementById('difficulty').value - 1];
            document.getElementById('nonMediumPercentageValue').textContent = document.getElementById('nonMediumPercentage').value;
            document.getElementById('nonMundanePercentageValue').textContent = document.getElementById('nonMundanePercentage').value;
            document.getElementById('specialTypePercentageValue').textContent = document.getElementById('specialTypePercentage').value;
        }

        // Attach event listeners to sliders
        document.addEventListener('DOMContentLoaded', () => {
            updateSliderValues(); // Initialize values on load

            document.querySelectorAll('.slider').forEach(slider => {
                slider.addEventListener('input', updateSliderValues);
            });
        });

        // Utility function to get a random element from an array
        function getRandomElement(array) {
            return array[Math.floor(Math.random() * array.length)];
        }

        // Function to calculate Threat MV from threat dice
        function calculateThreatMV(threatDice) {
            const [count, sides] = threatDice.split('d').map(Number);
            return count * sides;
        }

        // Function to calculate Hit Points based on base HP, size, and nature
        function calculateHitPoints(baseHP, size, nature) {
            const multiplier = hpMultipliers[size][nature];
            return {
                hitPoints: Math.round(baseHP * multiplier),
                multiplier: multiplier
            };
        }

        // Function to randomly select size for a trope, considering Non-Medium Size Percentage
        function getRandomSizeForTrope(trope, nonMediumPercentage) {
            const baseWeights = tropeConfig[trope]?.sizeWeights || { Minuscule: 0.5, Tiny: 1, Small: 2, Medium: 5, Large: 2, Huge: 1, Gargantuan: 0.5 };
            const adjusted = clampWeightsForNonMedium(baseWeights, nonMediumPercentage);
            // Remove zero-weight entries and normalize via weightedRandom
            const cleaned = Object.fromEntries(Object.entries(adjusted).filter(([, w]) => w > 0));
            return weightedRandom(cleaned);
        }

        // Function to randomly select nature for a trope, considering Non-Mundane Nature Percentage
        function getRandomNatureForTrope(trope, nonMundanePercentage) {
            const baseWeights = tropeConfig[trope]?.natureWeights || { Mundane: 6, Magical: 2, Preternatural: 1.5, Supernatural: 0.5 };
            const adjusted = clampWeightsForNonMundane(baseWeights, nonMundanePercentage);
            const cleaned = Object.fromEntries(Object.entries(adjusted).filter(([, w]) => w > 0));
            return weightedRandom(cleaned);
        }

        // Function to randomly determine creature type, considering Fast/Tough Creature Percentage
        function getCreatureType(specialTypePercentage) {
            if (Math.random() * 100 < specialTypePercentage) {
                return Math.random() < 0.5 ? 'Fast' : 'Tough';
            }
            return 'Normal';
        }

        // Function to calculate Battle Phase based on Prowess Die
        function calculateBattlePhase(prowessDie) {
            switch(prowessDie) {
                case 12: return 1;
                case 10: return 2;
                case 8: return 3;
                case 6: return 4;
                default: return 5;
            }
        }

        // Function to assign Weapon Reach based on size
        function assignWeaponReach(size) {
            const reachMap = {
                'Minuscule': 'short',
                'Tiny': 'short',
                'Small': 'short',
                'Medium': 'medium',
                'Large': 'medium',
                'Huge': 'long',
                'Gargantuan': 'long'
            };
            return reachMap[size] || 'medium';
        }

        // Function to generate a single monster
        function generateMonster(maxThreat, selectedTypes, selectedTropes, nonMediumPercentage, nonMundanePercentage, specialTypePercentage) {
            const category = getRandomElement(selectedTypes);
            const threatDice = getRandomElement(threatDiceByCategory[category]);
            const threatMV = calculateThreatMV(threatDice);
            const trope = getRandomTrope(selectedTropes);
            const size = getRandomSizeForTrope(trope, nonMediumPercentage);
            const nature = getRandomNatureForTrope(trope, nonMundanePercentage);
            const creatureType = getCreatureType(specialTypePercentage);

            const baseHP = threatMV;
            const { hitPoints, multiplier } = calculateHitPoints(baseHP, size, nature);

            let activeDefense, passiveDefense;
            if (creatureType === 'Fast') {
                activeDefense = Math.round(hitPoints * 0.75);
                passiveDefense = hitPoints - activeDefense;
            } else if (creatureType === 'Tough') {
                passiveDefense = Math.round(hitPoints * 0.75);
                activeDefense = hitPoints - passiveDefense;
            } else {
                activeDefense = Math.round(hitPoints / 2);
                passiveDefense = hitPoints - activeDefense;
            }

            // Assign a Prowess Die value for Battle Phase based on Threat Dice
            // Assuming Prowess Die corresponds to TD sides
            let prowessDie;
            switch(threatDice) {
                case '1d4':
                case '2d4':
                case '3d4':
                    prowessDie = 4;
                    break;
                case '1d6':
                case '2d6':
                case '3d6':
                    prowessDie = 6;
                    break;
                case '1d8':
                case '2d8':
                case '3d8':
                    prowessDie = 8;
                    break;
                case '1d10':
                case '2d10':
                case '3d10':
                    prowessDie = 10;
                    break;
                case '1d12':
                case '2d12':
                case '3d12':
                case '3d14':
                case '3d16':
                case '3d18':
                case '3d20':
                    prowessDie = 12;
                    break;
                default:
                    prowessDie = 6;
            }

            const battlePhase = calculateBattlePhase(prowessDie);
            const weaponReach = assignWeaponReach(size);

            // Define Saving Throw based on category
            const savingThrow = category === 'Legendary' ? 'd12' : `d${Math.min(12, 4 * ['Minor', 'Standard', 'Exceptional', 'Legendary'].indexOf(category) + 4)}`;

            return {
                trope,
                category, threatDice, threatMV, size, nature, creatureType,
                hitPoints, multiplier, activeDefense, passiveDefense,
                savingThrow: savingThrow,
                battlePhase: battlePhase,
                prowessDie: prowessDie,
                weaponReach: weaponReach
            };
        }

        // Function to generate the entire encounter
        function generateEncounter() {
            const partySize = parseInt(document.getElementById('partySize').value);
            const defenseLevel = defenseLevels[document.getElementById('defenseLevel').value - 1];
            const difficulty = parseInt(document.getElementById('difficulty').value);
            const nonMediumPercentage = parseInt(document.getElementById('nonMediumPercentage').value);
            const nonMundanePercentage = parseInt(document.getElementById('nonMundanePercentage').value);
            const specialTypePercentage = parseInt(document.getElementById('specialTypePercentage').value);
            const selectedTypes = Array.from(document.querySelectorAll('input[name="creatureTypes"]:checked')).map(checkbox => checkbox.value);
            const selectedTropes = Array.from(document.querySelectorAll('input[name="creatureTropes"]:checked')).map(cb => cb.value);
            if (selectedTypes.length === 0) {
                alert("Please select at least one creature type.");
                return;
            }
            if (selectedTropes.length === 0) {
                alert("Please select at least one creature trope.");
                return;
            }

            const threatScore = encounterDifficultyTable[partySize][defenseLevel][difficulty - 1];
            let output = `Eldritch RPG Encounter\n=========================\n`;
            output += `Party Size: ${partySize}\n`;
            output += `Defense Level: ${defenseLevel}\n`;
            output += `Difficulty: ${difficultyLevels[difficulty - 1]}\n`;
            output += `Total Threat Score: ${threatScore}\n\n`;
            output += `Creatures:\n=========================\n`;

            let remainingThreat = threatScore;
            let monsters = [];

            while (remainingThreat > 0) {
                const maxThreat = Math.min(remainingThreat, 36); // Assuming max threat per creature is 36
                const monster = generateMonster(maxThreat, selectedTypes, selectedTropes, nonMediumPercentage, nonMundanePercentage, specialTypePercentage);
                monsters.push(monster);
                remainingThreat -= monster.threatMV;

                // To prevent an infinite loop, break if no progress is made
                if (monster.threatMV === 0) break;
            }

            monsters.forEach((monster, index) => {
                output += `Monster ${index + 1}\n`;
                output += `Trope: ${monster.trope} | Type: ${monster.category} | TD: ${monster.threatDice} | `;
                output += `HP: ${monster.hitPoints} (${monster.activeDefense}/${monster.passiveDefense}) `;
                output += `[${monster.size}, ${monster.nature}; Ã—${monster.multiplier}] ${monster.creatureType}\n`;
                output += `ST: ${monster.savingThrow} | BP: ${monster.battlePhase}\n\n`;
            });

            document.getElementById('encounterOutput').textContent = output;
        }
    </script>
</body>
</html>